[ { "title": "网盘项目——后端登陆(三)", "url": "/posts/%E7%BD%91%E7%9B%98%E7%99%BB%E9%99%86/", "categories": "项目", "tags": "生活", "date": "2022-04-15 00:00:00 +0000", "snippet": "后端登陆API1.项目主要依赖spring-boot 2.2.2mybatis-plus 3.5.1java-jwt 3.18.2项目的后端技术栈为：spring\tspringboot\tmaven\tmybatis-plus\tmysql2.配置文件applicationspring: application:\t\t#配置启动服务器 name:Sans-cloud-server\t datasource:\t\t#配置mysql连接服务 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/cloud username: root password: 123456server: port: 8080 servlet: context-path: /api\t#将所有页面的前面加上/api，与前端请求保持一致3.创建Mysql数据库3.1 创建数据库及字段创建user表： 字段名 类型 备注 id bigint 主键，自增长，用户ID username varchar 用户名 userPassword varchar 用户密码 avatarURL varchar 用户头像URL createTime datetime 创建时间 updateTime datetime 修改时间 3.2 创建Model类及mapper类使用mybatis-X插件快速创建user表对应的实体类以及操作实体类的mapper类User类：/** * 用户表 * @TableName user */@TableName(value =\"user\")@Datapublic class User implements Serializable { /** * 用户id，自增长 */ @TableId(type = IdType.AUTO) private Long id; /** * 用户名 */ private String username; /** * 用户密码，以加密方式储存 */ private String userpassword; /** * 用户头像 超链接 */ private String avatarurl; /** * 创建时间 */ private Date createtime; /** * 修改时间 */ private Date updatetime; @TableField(exist = false) private static final long serialVersionUID = 1L;}UserMapper类：/** * @Entity com.sans.cloud.mapper *///BaseMapper类里集成着一些sql常用的增删改查语句，这就是mybatis-plus带来的方便public interface UserMapper extends BaseMapper&lt;User&gt; {}4. 创建util工具类ResultUtil类：/** * 处理返回前端信息 */@SuppressWarnings(\"all\")public class ResultUtil { /** * 前后端连接成功时使用的方法 * @param data * @param &lt;T&gt; * @return */ public static &lt;T&gt; ResponseResult&lt;T&gt; success(T data){ ResponseResult&lt;T&gt; result = new ResponseResult&lt;T&gt;();\t result.setCode(0); result.setMessage(true); result.setData(data); return result; } /** * 前后端连接失败时使用的方法 * @param msg * @param &lt;T&gt; * @return */ public static &lt;T&gt; ResponseResult&lt;T&gt; error(String msg) { ResponseResult&lt;T&gt; result = new ResponseResult&lt;&gt;(); result.setCode(-1); result.setMessage(msg); return result; }}TokenUtil类：/** * @author Sans */public class TokenUtil { private static final String SECRET = \"JKKLJOoasdlfj\"; /** * 使用JWT(Json web token)创建token值 * @param name * @return */ public static String createToken(String name){\t Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3); //header map.put(\"alg\", \"HS256\"); map.put(\"typ\", \"JWT\"); return JWT.create().withHeader(map) // payload .withClaim(\"iss\", \"Service\") // sign time .withClaim(\"aud\", \"WEB\").withClaim(\"username\", name) // signature .sign(Algorithm.HMAC256(SECRET)); }}5.创建Controller层方法@RestControllerpublic class UserController { @Resource private UserService userService; @PostMapping(\"/login\") public ResponseResult&lt;Object&gt; userLogin(@RequestBody UserLoginRequest userLoginRequest){ if (userLoginRequest == null) {\t//判断传值是否为空 return null; } String userName = userLoginRequest.username; String userPassword = userLoginRequest.password; if (StringUtils.isAllBlank(userName, userPassword)) { \t//判断用户名密码是否为空字符 return null; } return userService.userLogin(userName,userPassword);\t//传递参数到Service层处理数据 }}login方法返回值是一个自建的ResponseResult类，接受的参数是自建类UserLoginRequest类：/** * ResponseResult * 向前台返回后端处理的相关信息 * @author Sans */@Setter@Getter@Accessors(chain = true)public class ResponseResult&lt;T&gt; {\tprivate int code;\t//状态码\tprivate Object message;\t//状态信息\tprivate T data;\t//后台向前端返回的主体数据\tprivate Object count;\t//统计次数\t}@Data//该类用于接受前端传递来的值，因此变量名与前端参数名保持一致public class UserLoginRequest implements Serializable { public String username; public String password;}6.创建Service层6.1 UserService接口public interface UserService extends IService&lt;User&gt; { /** * 用户登陆 * @param userName 用户名 * @param userPassword 密码 * @return 返回脱敏后的信息 */ ResponseResult&lt;Object&gt; userLogin(String userName, String userPassword);}6.2 UserService实现类UserLogin方法：@Resource private UserMapper userMapper; //盐值，混淆密码 private static final String SALT = \"Sans\"; @Override public ResponseResult&lt;Object&gt; userLogin(String userName, String userPassword) { //1.校验 if(StringUtils.isAllBlank(userName,userPassword)){ //判断传值是否为空 return ResultUtil.error(\"用户名或密码不能为空\"); } if(userPassword.length()&lt;6){ return ResultUtil.error(\"密码长度不能小于6\"); } //2.加密 MD5算法，加盐值混淆 String md5_Password = DigestUtils.md5DigestAsHex((SALT+userPassword).getBytes()); //查询用户是否存在 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(\"username\",userName); queryWrapper.eq(\"userPassword\",md5_Password); User user = userMapper.selectOne(queryWrapper); //用户不存在 if(user==null){ log.info(\"user login failed，username cannot match userPassword\"); return ResultUtil.error(\"用户名或密码错误\"); } //3.记录用户登陆态,生成token String token = TokenUtil.createToken(userName); //4.用户脱敏 User safetyUser = getSafetyUser(user); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"token\",token); map.put(\"username\",safetyUser.getUsername()); map.put(\"UserId\",safetyUser.getId().toString()); return ResultUtil.success(map); }数据脱敏方法：/** * 用户数据脱敏 * @param user * @return */ public User getSafetyUser(User user){ User safetyUser = new User(); safetyUser.setId(user.getId()); safetyUser.setUsername(user.getUsername()); safetyUser.setUserpassword(user.getUserpassword()); safetyUser.setAvatarurl(user.getAvatarurl()); safetyUser.setCreatetime(user.getCreatetime()); return safetyUser; }" }, { "title": "网盘项目——前端(二)", "url": "/posts/%E7%BD%91%E7%9B%98%E5%89%8D%E7%AB%AF02/", "categories": "项目", "tags": "生活", "date": "2022-04-12 00:00:00 +0000", "snippet": "前端登陆模块的实现1.安装相关依赖\"vuex\": \"^4.0.2\"\"js-cookie\": \"^3.0.1\"\"axios\": \"^0.26.1\",vuex：管理全局变量，在登陆模块中的作用是调用登陆请求js-cookie：轻量级cookie管理组件axios：创建http请求2.登陆页面的设计2.1 HTML页面设计2.2 登陆事件流程图3.登陆页面的HTML代码&lt;div class=\"login-container\"&gt; &lt;el-card&gt; &lt;el-form ref=\"loginForm\" :model=\"loginForm\" :rules=\"loginRules\" class=\"login-form\" auto-\t\t complete=\"on\" label-position=\"left\" &gt; &lt;div class=\"title-container\"&gt; &lt;h3 v-if=\"!initialize\" class=\"title\"&gt; &lt;span class=\"Sans-cloud-log\"&gt;&lt;svg-icon icon-class=\"Sans-cloud\"&gt;&lt;/svg-icon&gt;&lt;/span&gt; &lt;span&gt;SansCloud&lt;/span&gt; &lt;/h3&gt; &lt;h3 v-if=\"initialize\" class=\"title\"&gt;用户注册&lt;/h3&gt; &lt;/div&gt; &lt;!--用户名输入框--&gt; &lt;el-form-item prop=\"username\"&gt; &lt;span class=\"svg-container\"&gt; &lt;svg-icon icon-class=\"user\" /&gt; &lt;/span&gt; &lt;el-input ref=\"username\" v-model=\"loginForm.username\" placeholder=\"用户名\" name=\"username\" type=\"text\" tabindex=\"1\" auto-complete=\"on\" /&gt; &lt;/el-form-item&gt; &lt;!--密码输入框--&gt; &lt;el-form-item prop=\"password\"&gt; &lt;span class=\"svg-container\"&gt; &lt;svg-icon icon-class=\"password\" /&gt; &lt;/span&gt; &lt;el-input :key=\"passwordType\" ref=\"password\" v-model=\"loginForm.password\" :type=\"passwordType\" placeholder=\"密码\" name=\"password\" tabindex=\"2\" auto-complete=\"on\" @keyup.enter=\"handleLogin\" /&gt; &lt;span class=\"show-pwd\" @click=\"showPwd\"&gt; &lt;svg-icon :icon-class=\"passwordType==='password'?'eye':'eye-open'\" /&gt; &lt;/span&gt; &lt;/el-form-item&gt; &lt;!-- 自动登陆--&gt; &lt;el-form-item v-if=\"!initialize\" class=\"remember\"&gt; &lt;el-checkbox label=\"记住我\" v-model=\"loginForm.rememberMe\"&gt;&lt;/el-checkbox&gt; &lt;/el-form-item&gt; &lt;!--确认密码--&gt; &lt;el-form-item v-if=\"initialize\" prop=\"confirmPassword\"&gt; &lt;span class=\"svg-container\"&gt; &lt;svg-icon icon-class=\"password\" /&gt; &lt;/span&gt; &lt;el-input :key=\"passwordType\" ref=\"password\" v-model=\"loginForm.confirmPassword\" :type=\"passwordType\" placeholder=\"确认密码\" name=\"password\" tabindex=\"2\" auto-complete=\"on\" @keyup.enter=\"handleLogin\" /&gt; &lt;span class=\"show-pwd\" @click=\"showPwd\"&gt; &lt;svg-icon :icon-class=\"passwordType === 'password' ? 'eye' : 'eye-open'\" /&gt; &lt;/span&gt; &lt;/el-form-item&gt; &lt;el-button :loading=\"loading\" type=\"primary\" style=\"width:100%;margin: 30px 0;\" @click=\"handleLogin\"&gt;&lt;/el-button&gt; &lt;/el-form&gt; &lt;/el-card&gt; &lt;/div&gt;4.登陆页面的vue.js代码4.1 前端校验对密码和确认密码进行前端的校验export default{\tname:'loginModel' data(){ \t/** * 前端校验 * @param rule * @param value * @param callback */ const validatePassword = (rule, value, callback) =&gt; { if (value.length &lt; 6) { callback(new Error('密码不能少于6位数字')) } else { callback() } } const confirmPassword = (rule, value, callback) =&gt; { if (value.length &lt; 6) { callback(new Error('密码不能少于6位数字')) } else if(this.loginForm.password !== value) { callback(new Error('密码不一致')) } else { callback() } } }}4.2 return 管理数据变量return{ loginForm:{ username:'', password: '', rememberMe: false, confirmPassword: '' }, loginRules: { password: [{ required: true, trigger: 'blur', validator: validatePassword }], confirmPassword: [{ required: true, trigger: 'blur', validator: confirmPassword }] }, loading: false, passwordType: 'password', redirect: undefined, initialize: false, //todo 用于切换登陆和注册状态 }}4.3 methods 显示隐藏密码showPwd() { //todo 显示隐藏密码 if (this.passwordType === 'password') { this.passwordType = '' } else { this.passwordType = 'password' } this.$nextTick(() =&gt; { this.$refs.password.focus() })},5. 登陆事件——配置前后端连接API5.1 创建request.js在utils文件夹中创建request.js，作为创建请求的文件创建请求用到了axios组件import axios from \"axios\";// 创建axios实例const service = axios.create({})export default service5.2 创建user.js创建一个api文件夹，里面新建一个user.js 作为用户登陆的APIuser.js中声明的是各种前后端连接的请求方法，通过axios实现与后端接口的连接import request from '@/utils/request'\t\t//导入request.js/** * 向后端发送登陆的post请求 */export function login(data) { return request({ url: 'login', method: 'post', data })}/** * 向后端发送初始化的post请求（新建用户） * @param data */export function initialization(data) { return request({ url: '/public/initialization', method: 'post', data })}6. 登陆事件——配置store6.1 创建store文件夹以及index.js文件开始进行登陆事件的前置配置，因为使用了vuex作为管理全局变量的工具，所以要先创建一个store文件夹。然后再该文件夹中创建index.js==在vuex4中，创建实例不再用 new Vuex 而是换成了 createStore==import { createStore } from 'vuex'import user from '@/store/modules/user'\t//导入modules中的user模块const store = createStore({ modules: {\t\t//模块化管理 user }})export default store6.2 创建modules文件夹以及user.js文件vuex中为了对项目的管理更加方便直观，可以对store进行分割为一个个的模块，每个模块拥有自己的 state、mutation、action、getter然后在该文件夹中创建 user.js文件 作为传递登陆参数的模块import {login} from '@/api/user'const actions= { /** * user login（用户登陆） * @param commit * @param userInfo * @returns {Promise&lt;unknown&gt;} */ login({ commit }, userInfo) { const { username, password, rememberMe } = userInfo return new Promise((resolve, reject) =&gt; { //将参数传递到/api/user.js中的login方法中，当前后端请求成功后执行response方法，实现cooike等功能 login({ username: username.trim(), password: password }).then(response =&gt; { const { data } = response commit('SET_TOKEN', data.token) setToken(data.token) commit('SET_USERID', data.userId) setConsumerId(data.userId) if(rememberMe){ setRememberName(username) } else { removeRememberName() } resolve() }).catch(error =&gt; { reject(error) }) }) },}export default { namespaced: true, actions}6.3 引入store组件接着在全局变量main.js中引入组件/** * 引入store 组件 */import { createApp } from 'vue'import App from './App.vue'import store from \"@/store/index\";const app = createApp(App)app.use(store)app.mount('#app')7.登陆事件——点击登陆的方法在配置好了连接api以及store容器后，就可以实现点击登陆按钮的方法handleLogin()了首先要在export default之前导入登陆事件需要的组件 import store from \"@/store/index\";\t\t\t\t//引入store组件 import {initialization} from \"@/api/user\";\t\t//引入initialization方法登陆/注册方法：handleLogin(){ this.$refs.loginForm.validate(valid =&gt; { if(valid){ if(this.initialize){ //todo 创建新用户,初始化数据 let data = new FormData() data.append('username',this.loginForm.username) data.append('password',this.loginForm.password) initialization(data).then(()=&gt;{ this.initialize = false this.$message.success(\"创建成功\") }) }else{ //todo 通过dispatch调用store里的user.js中的login方法进行登陆 this.loading = true //todo Vuex4中取消了 this.$store的方式 store.dispatch('user/login', this.loginForm).then(()=&gt;{ }).catch(()=&gt;{ this.loading = false }) } }else{ return false } })},8.效果展示" }, { "title": "Vue3.x 引入自定义svg文件的流程", "url": "/posts/svg%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E5%85%A5/", "categories": "随笔", "tags": "生活", "date": "2022-04-08 00:00:00 +0000", "snippet": "Vue3.x 引入自定义svg文件的流程版本相关\"vue\": \"^3.2.13\"\"vue-router\": \"^4.0.14\"\"@vue/cli-service\": \"~5.0.0\"\"svg-sprite-loader\": \"^6.0.11\"引入 svg-sprite-loader 依赖第一步要引入相关依赖——svg-sprite-loadernpm i -D svg-sprite-loaderyarn add -D svg-sprite-loader创建svg相关文件在根目录创建svg的相关文件和文件夹。src—&gt;icons—&gt;svg文件夹：放置网站所需要的svg文件​\t\t icons—&gt;index.js文件：编写svg文件控制脚本src—&gt; components—&gt;SvgIcon—&gt;index.vue：编写svg组件的样式SvgIcon/index.vue 编写svg组件样式&lt;template&gt; &lt;svg :class=\"svgClass\" v-bind=\"$attrs\"&gt;\t &lt;use :xlink:href= \"iconName\"/&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'SvgIcon', props: { iconClass: { type: String, required: true }, className: { type: String, default: '' } }, computed: { iconName() { return `#icon-${this.iconClass}` }, svgClass() { if (this.className) { return 'svg-icon' + this.className } else { return 'svg-icon' } }, } }&lt;/script&gt;&lt;style lang=\"scss\"&gt; .svg-icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; }&lt;/style&gt;icons/index.js 编写svg文件控制脚本const req = require.context('./svg', false, /\\.svg$/)const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)requireAll(req)\t\t//获取svg文件夹中的所有svg文件main.js 注册svg全局组件import { createApp } from 'vue'import App from './App.vue'const app = createApp(App)/** * 引入svg-icon组件 */import '@/icons/index'import SvgIcon from \"@/components/SvgIcon/index\"app.component('svg-icon',SvgIcon)app.mount('#app')\tvue.config.js 配置chainWebpackconst path = require('path')function resolve(dir) { return path.join(__dirname, dir)}module.exports = { chainWebpack: config =&gt; { config.module .rule('svg') .exclude.add(resolve('src/icons/svg')) .end() config.module .rule('icons') .test(/\\.svg$/) .include.add(resolve('src/icons/svg')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options({ symbolId: 'icon-[name]' }) .end() }}完成引入完成引入之后就可以在页面中通过来引入svg文件" }, { "title": "网盘项目——前端(一)", "url": "/posts/%E7%BD%91%E7%9B%98%E5%89%8D%E7%AB%AF01/", "categories": "项目", "tags": "生活", "date": "2022-04-05 00:00:00 +0000", "snippet": "VueCli项目的启动与Login页面的路由挂载[TOC]项目依赖\"vue\": \"^3.2.13\"\"vue-router\": \"^4.0.14\"\"element-plus\": \"^2.1.8\"\"@vue/cli-service\": \"~5.0.0\"\"sass-loader\": \"^12.6.0\"1.vue项目的启动这个网盘项目是在WebStrom上面直接新建Vue.js项目，因此相比于在命令行使用npm缺少了版本选择等一些细节，但是这些都可以在项目终端中进行修改创建完项目之后进行依赖注入（npm/yarn）就可以正式开始进行项目设计了2.项目设计App.vue：作为网页的主入口，承担对子页面的路由分发功能。启动项目后进入页面默认Path：’/’login：登陆页面，经过路由挂载，由路由渲染页面。Path：’/login’3.修改App.vue页面App.vue页面是整个Vue项目中页面的资源首加载项，所有页面都是在其下进行切换的。对它的修改首先是将项目默认生成的页面信息删除掉。接着导出App实例，作为其他模块的导入（export default）&lt;script&gt; /** * 导出App实例，作为其他模块的导入 * @type {string[]} */ export default { name: 'App', components: {}, }4.创建登陆相关页面这里我新建了一个views文件夹存储所有子页面文件，在views中建立Login文件夹，内建index.vue作为登陆页面5.创建router相关文件为了使用vue-router，必须在项目目录中创建一个router文件夹，内建index.js文件作为配置路由信息的存储页面index.js内的信息大致分为四块：1、配置路由及相关引入2、创建路由基本信息3、实例化路由4、导出路由/** * 引入VueRouter (Vue3.X配置路由的方式) */import {createRouter, createWebHistory} from 'vue-router'/** * 创建静态路由 */const constantRoutes = [ // 路由的默认路径 { path: '/', redirect: '/login'\t//重定向，即进入主页面立刻重定向到login页面 }, { path: '/login', component: () =&gt; import('@/views/Login/index.vue'), },]/** * 实例化静态路由 */const router = createRouter({ history:createWebHistory(), routes:constantRoutes})/** * 导出路由 */export default router6.进行路由挂载到App.vue在完成了路由配置之后，导出的路由信息在main.js中完成导入。main.js：是项目的入口文件 ，项目的所有页面都会加载main.js，主要有三个作用1、实例化Vue。2、放置项目中经常会用到的插件和CSS样式。例如： 网络请求插件:axios和vue-resource、图片懒加载插件：vue-lazyload3、存储全局变量。例如（用于路由的基本信息）import { createApp } from 'vue'import App from './App.vue'\t//导入App.vue中的实例App/** * 引入elementUI PLUS 因为elementUI只支持Vue2.X 如果项目是Vue3.X就会不适配 */import ElementPlus from 'element-plus';import 'element-plus/theme-chalk/index.css'const app = createApp(App)app.use(ElementPlus)/** * 路由导入，从路由渲染页面 */import router from './router/index'app.use(router)app.mount('#app')\t//路由挂载至此login子页面的路由挂载功能完成" }, { "title": "mybatis/mybatis-plus与mysql的字段驼峰命名冲突的问题", "url": "/posts/mybatis/", "categories": "随笔", "tags": "生活", "date": "2022-04-01 00:00:00 +0000", "snippet": "驼峰命名冲突问题在引入Mybatis/Mybatis-plus之后，如果没有对mysql字段命名方式进行设置，那么就会出现命名冲突的情况。例如：在mysql中创建的字段名是uploadTime，而相应的model层内Mybatis设置的是upload_time。这样的话在运行代码时就会发生在数据库中找不到目标字段的错误。解决方法：在application.yml文件中添加Mybatis的驼峰命名转换字段mybatis/mybatis-plus: configuration: map-underscore-to-camel-case: false " }, { "title": "使用spring框架的MultipartFile上传文件报错", "url": "/posts/TheCloud/", "categories": "随笔", "tags": "生活", "date": "2022-04-01 00:00:00 +0000", "snippet": "在做网盘的多文件上传功能时，使用spring框架的MultipartFile上传文件报错代码文件：/** * 上传文件 * @param md5 * @param file */ public void upload(String name, String md5, MultipartFile file) throws IOException { String path = UploadConfig.path + generateFileName(); FileUtils.write(path, file.getInputStream()); fileDao.save(new File(name, md5, path, new Date())); }报错信息：java.io.IOException: java.io.FileNotFoundException: D:\\Administrator\\Documents\\Java\\Project4\\boot\\work\\Tomcat\\localhost\\ROOT\\userfiles\\1\\程序附件\\theFile\\problem\\882b77ffb7f74e6984cc1cf909fd3b59.mp3 (系统找不到指定的路径。)\tat org.apache.catalina.core.ApplicationPart.write(ApplicationPart.java:122) ~[tomcat-embed-core-8.5.32.jar:8.5.32]\tat org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile.transferTo(StandardMultipartHttpServletRequest.java:255) ~[spring-web-5.0.8.RELEASE.jar:5.0.8.RELEASE]\tat com.jeeplus.modules.file.web.TheFileController.upload(TheFileController.java:284) ~[classes/:na]\tat com.jeeplus.modules.file.web.TheFileController$$FastClassBySpringCGLIB$$b6b3e23b.invoke(&lt;generated&gt;) ~[classes/:na]\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) ~[spring-core-5.0.8.RELEASE.jar:5.0.8.RELEASE]\tat 解决过程：经过debug排查发现问题出在application.yml文件里设置的相对路径没有被MultipartFile成功识别，于是把相对路径换成了绝对路径upload: path: D:/DeskTop/data/问题解决" } ]
